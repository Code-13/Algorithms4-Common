### 2.4 优先队列(Priority queues)

优先队列最重要的操作就是**插入元素**和**删除最大元素**。

**应用场景：**在某些数据处理的场合，**总数据量太大**（可以认为输入是无限的），无法排序（甚至无法全部装进内存）。如果将每个新的输入和已知的 M 个最大（或最小）元素比较，除非 M 较小，否则这种比较的代价会非常高昂。如果有了**优先队列**，就只用一个能存储 M 个元素的队列即可。

#### 2.4.1 API

优先级队列的特征在于删除最大值和插入操作。 按照惯例，我们将仅使用 less() 方法比较键值，就像我们一直在进行排序一样。 因此，如果记录可以有重复的键，则 maximum 表示最大键值之一。 要完成 API，我们还需要构造函数和测试是否为空操作。 为了灵活性，我们使用通用类型 Key 实现 Comparable 的通用实现。

![](https://algs4.cs.princeton.edu/24pq/images/pq-api.png)

### 2.4.2 初级实现

- 数组实现（无序）：惰性方法，仅在必要的时候找出最大元素；
- 数组实现（有序）：积极方法：在插入时就保持列表有序，使后续操作更高效；
- 链表表示法

![](https://algs4.cs.princeton.edu/24pq/images/pq-array.png)

在上述优先队列的初级实现中，**删除最大元素**和**插入元素**这两个操作之一在最坏情况下需要**线性**时间来完成。

| 数据结构 | 插入元素 | 删除最大元素 |
| :------: | :------: | :----------: |
| 有序数组 |    N     |      1       |
| 无序数组 |    1     |      N       |
|    堆    |   logN   |     logN     |
| 理想情况 |    1     |      1       |

#### 2.4.3 堆的定义

当一棵二叉树的每个结点都**大于等于**它的两个子结点时，它被称为**堆有序**。

根结点是堆有序的二叉树中的最大结点。

##### 二叉堆表示法

如果使用指针来表示堆有序的二叉树，那么每个元素都需要**三个指针**来找到它的上下结点。

但使用完全二叉树，只需要数组而不需要指针就可以表示，十分方便。具体方法是将二叉树的结点按照**层级顺序**放入数组中。

![](https://algs4.cs.princeton.edu/24pq/images/heap.png)

**定义**：**二叉堆**（后文简称为堆）是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。

![](https://algs4.cs.princeton.edu/24pq/images/heap-representations.png)

在一个堆中，位置`k`的结点的父结点的位置为`⌊k/2⌋`，子结点位置分别为`2k`和`2k+1`。

**高性能的原因**：利用在数组中无需指针即可沿树上下移动的便利。

> 注：完全二叉树：除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。
>
> 一棵大小为 N 的完全二叉树的高度为`⌊lgN⌋`。
>

#### 2.4.4 堆的算法

我们在长度为 *n* + 1 的私有数组 `pq []`中表示大小为 *N* 的堆，其中`pq [0]`未使用且堆在`pq [1]`到`pq [n]中`。我们只通过函数`less()` 和`exch()`来访问元素。

**堆的有序化**：打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。

##### 2.4.4.1 由下至上的堆序列化（上浮）

```java
private void swim（int k）{
   while（k> 1 && less（k / 2，k））{
      exch（k，k / 2）;
      k = k / 2;
   }
}
```

![](https://algs4.cs.princeton.edu/24pq/images/sink.png)

##### 2.4.4.2 由上至下的堆序列化（下沉）

```java
private void sink（int k）{
   while（2 * k <= N）{
      int j = 2 * k;
      if（j <N && less（j，j + 1））j ++;
      if（！less（k，j））break;
      exch（k，j）;
      k = j;
   }
}
```

![](https://algs4.cs.princeton.edu/24pq/images/sink.png)

**插入元素**时，将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置。

**删除最大元素**时，从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置。

![](https://algs4.cs.princeton.edu/24pq/images/heap-ops.png)

这样，**删除最大元素**和**插入元素**这两个操作的用时和队列的大小仅成**对数**关系。对于一个含有 N 个元素的基于堆的优先队列，插入元素操作只需不超过 (lgN+1) 次比较，删除最大元素的操作需要不超过 2lgN 次比较。

**基于堆的优先队列：** 

详情请看：[MaxPQ.java](https://algs4.cs.princeton.edu/24pq/MaxPQ.java.html) 和 [MinPQ.java中实现](https://algs4.cs.princeton.edu/24pq/MinPQ.java.html)

![](https://algs4.cs.princeton.edu/24pq/images/heap-pq.png)

#### 2.4.5 堆排序


```
    private static void sink(Comparable[] pq, int k, int n) {
        while (2*k <= n) {
            int j = 2*k;
            if (j < n && less(pq, j, j+1)) j++;
            if (!less(pq, k, j)) break;
            exch(pq, k, j);
            k = j;
        }
    }


```
> for循环构造了堆，然后while循环将最大的元素 a[1] 和 a[N] 交换并恢复了堆，如此重复知道堆变空。将 exch() 和 less() 实现中的索引减一即可得到和其他排序算法一致的实现（将 a[0] 至 a[N-1] 排序）。

![堆排序具体流程示意图](https://algs4.cs.princeton.edu/24pq/images/heapsort-trace.png)
![堆排序的轨迹-每次下沉后的数组内容](https://algs4.cs.princeton.edu/24pq/images/heapsort.png)

##### 2.4.5.2 下沉排序
堆排序的主要工作都是在第二阶段完成。这里我们将堆中的最大元素删除，然后放入堆缩小后数组中空出的位置。这个过程和选择排序有些类似（按照降序而非升序取出所有的元素），但所需的比较要少很多，因为堆提供了一种从未排序部分找到最大元素的有效方法。


